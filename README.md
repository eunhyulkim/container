# RFC 7230~7235 기반 웹서버

**웹서버**는 RFC 7230~7235(HTTP 1.1)에 따라 nginx와 같은 웹서버를 직접 구현한 프로젝트입니다.

## Developer
김은휼, 박용준, 주정현 세 명에 의해 만들어졌습니다. 이 프로젝트는 페어 프로그래밍에 의해 진행된 프로젝트입니다. 모두 함께 라이브 코딩을 하거나, 최소한 코드 리뷰에 적극적으로 참여하는 방식으로 이루어졌습니다.

## Why
REST API, HTTP 등 웹 개발의 기반이 되는 CS 지식의 부족함을 느꼈습니다. 서버/클라이언트, Request/Response 등도 개념적 수준에서 이해하는 것을 넘어, 전체 과정을 구현 레벨에서 알아야 탄탄한 기초 위에서 웹 개발을 해갈 수 있을 것으로 판단했습니다.

## Feature
다음과 같은 점들에 유의하여 개발했습니다.

- 객체 지향 패러다임(OOP)으로 설계했습니다. C++로 C 스타일의 코드를 작성하지 않았습니다.
- RFC 7230~7235를 가능한 충족시키는 웹 서버를 설계하려고 했습니다. 모든 header를 구현하지는 않았지만, 주요 header들은 빠짐없이 구현했습니다.
- nginx가 HTTP/1.1을 만족하는 것으로 간주하기 때문에, HTTP/1.1이 어떻게 동작하는가에 대해서 의문이 있을 경우 nginx의 작동과 비교하여 구현했습니다.
- 서버가 특정 클라이언트와의 IO작업에 묶이지(blocking) 않도록, 모든 클라이언트와의 작업에 있어서 select 함수를 단 1번만 사용하여 관리했습니다.
- 서버가 죽거나, 멈추거나, 클라이언트에 묶여서는 안 되며 필요하다면 클라이언트를 튕겨낼 수 있도록 했습니다.
- select 작업으로 읽기 작업이나 쓰기 작업이 가능한지 확인하지 않은 상태에서 입출력 작업을 진행하지 않았습니다.
- read/write 작업 뒤에 errno를 체크하여 예외처리를 진행하는 것은 엄격히 금지했습니다. 에러가 발생하면 에러의 원인과 관계없이 클라이언트 커넥션을 제거했습니다.
- 어떤 이유로든 리퀘스트가 처리되지 않고 서버에 남아있는 경우가 생기도록 하지 않았습니다.
- 필요한 경우 상황에 맞는 에러 페이지를 리턴할 수 있도록 했습니다.
- 어떤 경우에도 memory leak이나 crash를 일으키지 않도록 주의했습니다.

## Stack
- **C++**: 언어 차원에서 TCP/IP 레벨의 커넥션을 맺고 스레드 풀을 관리할 수 있는 경우로 C++이 적합하다고 판단했습니다. 네트워크를 로우 레벨에서 이해하고 싶었기 때문에, chunked body를 직접 프로토콜에 맞게 읽어드리고, 헤더를 직접 읽어서 처리하는 과정 등을 모두 직접 수행하고자 했습니다. 동적 할당과 해제를 통해 메모리 관리가 자유로우면서도, C와 달리 객체지향의 특성을 가지고 있습니다. 또 다양한 자료구조를 활용할 수 있다는 점도 목적에 부합했습니다.

## Process
이 프로젝트에 대해 필요한 기술을 학습하여 개발해나가는 모든 과정을 <웹서버 개발 가이드>로 따로 문서화했습니다.
* [개발 가이드 읽기](https://42seoul.gitbook.io/webserv/)

## Performance
다음과 같은 함수를 이용하여 서버의 전체 프로세스 곳곳에 심어두고, 플래그를 이용하여 구간별 속도를 usecond 단위로 측정했습니다.
```
std::string getSpeed(timeval from)
{
    timeval t;
    gettimeofday(&t, NULL);
    return (ft::to_string((t.tv_sec - from.tv_sec) * 1000000 + (t.tv_usec - from.tv_usec)));
}
```
20개의 클라이언트를 이용하여 1억 바이트의 Body Size를 가진 POST 요청을 각각 5번씩 보내는 자체 부하 테스트(1억 request * 100)를 모두 처리하는데, 처참하게도 1시간의 시간이 소요되는 것을 확인했습니다.
시간이 많이 소요되는 단계들을 찾아내고, 그 안에서 세부 플래그들을 세워서 시간이 특히 많이 소요되는 구간이나 함수들을 찾아냈습니다. 분석 결과를 토대로 2가지의 큰 변화를 줬습니다.
하나는 CGI 프로그램을 POST 메소드로 실행할 때 요청 메시지의 바디를 버퍼에 저장하지 않고 바로 CGI 프로그램으로 넘겼습니다.
다른 하나는, 버퍼(String 클래스)에서 데이터를 사용한 후 erase하는 것이 아니라 index를 바꾸는 방식으로 erase 작업을 없앴습니다.
그 결과 최종적으로 같은 크기의 부하 테스트를 2분 안쪽으로 처리할 수 있었습니다.
